from pathlib import Path
import numpy as np
import pinocchio as pin
from typing import Dict, Tuple, Optional
from dataclasses import dataclass
from .ik_solver import HandIKSolver, Position

@dataclass
class Pose:
    """Represents position and optional orientation"""
    position: Position
    orientation: Optional[np.ndarray] = None
    
@dataclass 
class JointAngles:
    """Container for joint angles"""
    angles: Dict[str, float]
    
@dataclass
class FingerTargets:
    """Container for finger target positions"""
    positions: Dict[str, Position]

class HandKinematicsBase:
    """Base class for hand kinematics calculations"""
    
    def __init__(self, urdf_path: Path, config_path: Path):
        self.robot = pin.RobotWrapper.BuildFromURDF(str(urdf_path))
        self.config_path = config_path
        self._init_frames()
        self.ik_solvers = {}

        
    def _init_frames(self):
        """Initialize frame IDs for each finger tip"""
        self.finger_frames = {
            'thumb': 'r_f_link1_4',
            'index': 'r_f_link2_4',
            'middle': 'r_f_link3_4',
            'ring': 'r_f_link4_4',
            'pinky': 'r_f_link5_4'
        }
        
        self.frame_ids = {
            finger: self.robot.model.getFrameId(frame)
            for finger, frame in self.finger_frames.items()
        }

    def forward_kinematics(
        self,
        joint_angles: JointAngles,
        base_pose: Optional[Pose] = None,
        frame: str = 'hand'
    ) -> Dict[str, Pose]:
        """
        Compute forward kinematics for all fingers
        
        Args:
            joint_angles: Current joint angles
            base_pose: Optional base pose of the hand
            frame: Reference frame
        Returns:
            Dictionary of finger poses
        """
        q = np.zeros(self.robot.model.nq)
        for joint, angle in joint_angles.angles.items():
            idx = self.robot.model.getJointId(joint)
            q[idx] = angle
            
        pin.forwardKinematics(self.robot.model, self.robot.data, q)
        pin.updateFramePlacements(self.robot.model, self.robot.data)
        
        poses = {}
        for finger, frame_id in self.frame_ids.items():
            transform = self.robot.data.oMf[frame_id]
            poses[finger] = Pose(
                position = Position(
                    x=transform.translation[0],
                    y=transform.translation[1],
                    z=transform.translation[2]
                ),
                orientation = transform.rotation
            )
            
        return poses

    def inverse_kinematics_finger(
        self,
        finger: str,
        target_pos: Position,
        frame: str = 'hand',
        initial_guess: Optional[JointAngles] = None
    ) -> Tuple[JointAngles, bool]:
        """
        Solve IK for a single finger
        
        Args:
            finger: Target finger name
            target_pos: Target position
            frame: Reference frame
            initial_guess: Initial joint angles
        Returns:
            Tuple of (joint angles, success flag)
        """
        if finger not in self.ik_solvers:
            self.ik_solvers[finger] = HandIKSolver(
                self.robot,
                self.finger_frames[finger],
                config_path=self.config_path  # 需要添加这个参数
            )

        if initial_guess is not None:
            q0 = np.zeros(self.robot.model.nq)
            for joint, angle in initial_guess.angles.items():
                idx = self.robot.model.getJointId(joint)
                q0[idx] = angle
        else:
            q0 = None
            
        q, success = self.ik_solvers[finger].solve(target_pos, q0)
        
        result = {}
        for joint in self.robot.model.names:
            if joint.startswith(f'r_f_joint{finger[0]}'):
                idx = self.robot.model.getJointId(joint)
                result[joint] = q[idx]
                
        return JointAngles(angles=result), success

    def inverse_kinematics_grasp(
        self,
        finger_targets: FingerTargets,
        frame: str = 'hand',
        initial_guess: Optional[JointAngles] = None
    ) -> Tuple[JointAngles, bool]:
        """
        Solve IK for multiple fingers simultaneously
        
        Args:
            finger_targets: Target positions for each finger
            frame: Reference frame
            initial_guess: Initial joint angles
        Returns:
            Tuple of (joint angles for all fingers, success flag)
        """
        all_results = {}
        all_success = True
        
        for finger, target in finger_targets.positions.items():
            result, success = self.inverse_kinematics_finger(
                finger, target, frame, initial_guess
            )
            all_results.update(result.angles)
            all_success &= success
            
        return JointAngles(angles=all_results), all_success

base.py中方法forward_kinematics，inverse_kinematics_finger，inverse_kinematics_grasp的参数frame其实是正逆运动学的参考坐标系，
可以选 hand 或者 world